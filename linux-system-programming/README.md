# Linux System Programming

> 시스템 콜과 라이브러리 함수를 활용한 리눅스 시스템 프로그래밍 학습 프로젝트

## 프로젝트 개요

이 저장소는 리눅스 운영체제의 시스템 콜과 라이브러리 함수를 직접 활용하여 운영체제와 상호작용하는 프로그래밍 방법을 학습하고 실습한 내용을 담고 있습니다. 단순히 고수준 API나 프레임워크를 사용하는 것이 아닌, 직접 시스템 콜을 호출함으로써 운영체제의 내부 동작 원리를 이해하고 저수준 프로그래밍 기술을 습득하는 것을 목표로 합니다.

## 핵심 학습 주제

### 시스템 콜과 라이브러리 함수

- **시스템 콜의 본질**: 유저 공간에서 커널 공간으로의 제어 전환을 통한 운영체제 서비스 요청
- **시스템 콜 vs 라이브러리 함수**: 직접적인 OS 호출과 추상화된 라이브러리 인터페이스의 차이점
- **시스템 콜 오버헤드**: 컨텍스트 스위칭과 성능 영향

### 주요 시스템 영역별 프로그래밍

- **파일 시스템**: 저수준 파일 I/O, 디렉토리 관리, 파일 시스템 탐색
- **프로세스 관리**: 프로세스 생성, 종료, 상태 모니터링, 스레드 관리
- **메모리 관리**: 메모리 할당, 공유 메모리, 메모리 매핑
- **프로세스 간 통신**: 파이프, 소켓, 메시지 큐, 공유 메모리
- **신호 처리**: 시그널 핸들링, 프로세스 간 신호 전송
- **네트워킹**: 소켓 프로그래밍, 네트워크 인터페이스 제어

## 심화 프로젝트

### 커스텀 쉘 (Custom Shell)
기본적인 명령어 실행, 파이프, 리다이렉션, 백그라운드 프로세스 등 리눅스 쉘의 핵심 기능을 직접 구현했습니다. 이 프로젝트는 프로세스 생성 및 관리, 파일 디스크립터 조작, 시그널 처리 등의 시스템 콜을 활용합니다.

### 시스템 모니터링 도구 (System Monitor)
/proc 파일시스템을 활용하여 CPU, 메모리, 디스크, 네트워크 사용량과 프로세스 정보를 실시간으로 모니터링하는 도구입니다. 파일 I/O와 문자열 처리 시스템 콜을 집중적으로 활용합니다.

### 미니 컨테이너 (Mini Container)
리눅스 네임스페이스와 cgroups를 활용하여 간단한 컨테이너를 구현했습니다. 프로세스 격리, 리소스 제한, 네트워크 네임스페이스 설정 등 컨테이너의 핵심 기능을 직접 시스템 콜을 통해 구현합니다.

### 비동기 I/O 서버 (Async I/O Server)
epoll/select 시스템 콜을 활용한 고성능 비동기 I/O 서버입니다. 단일 스레드로 다수의 클라이언트 연결을 효율적으로 처리하는 방법을 구현했습니다.

## 기술 스택

- **언어**: C
- **환경**: Linux (Ubuntu/Fedora)
- **주요 시스템 콜**: fork, exec, open, read, write, mmap, socket, select/poll/epoll, signal 등
- **빌드 도구**: Make, GCC

## 이 프로젝트를 통해 배운 점

이 프로젝트를 통해 고수준 추상화 아래에서 실제로 일어나는 일을 이해하고, 운영체제와 직접 상호작용하는 방법을 배웠습니다. 이러한 저수준 지식은 백엔드 및 클라우드 개발에서 많은 이점들을 제공합니다.

- **성능 최적화**: 시스템 자원을 효율적으로 활용하는 방법 이해
- **디버깅 능력 향상**: 문제가 발생했을 때 운영체제 수준에서 원인 파악 가능
- **시스템 설계 역량 강화**: 하드웨어와 소프트웨어의 상호작용을 고려한 설계 가능
- **클라우드 인프라 이해**: 가상화, 컨테이너화의 기본 원리 파악

## 라이센스

이 프로젝트는 MIT 라이센스 하에 배포됩니다.